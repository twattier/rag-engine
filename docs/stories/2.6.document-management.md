# Story 2.6: Implement Document Management API (List, Retrieve, Delete)

**Epic:** Epic 2 - Multi-Format Document Ingestion Pipeline
**Story ID:** 2.6
**Status:** Draft
**Estimated Effort:** 4 story points (5-6 hours)

---

## User Story

**As a** RAG Engine user,
**I want** to list, retrieve details, and delete ingested documents,
**so that** I can manage my knowledge base content.

---

## Acceptance Criteria

1. API endpoint `GET /api/v1/documents` returns paginated list of documents with: document_id, filename, metadata, ingestion_date, status, size
2. Query parameters support filtering: metadata fields (e.g., `?department=engineering`), date ranges, status
3. API endpoint `GET /api/v1/documents/{document_id}` returns full document details including parsed content preview
4. API endpoint `DELETE /api/v1/documents/{document_id}` removes document and associated graph nodes/relationships from Neo4j
5. Delete operation is idempotent—deleting non-existent document returns 204 (no error)
6. Document listing supports pagination with `limit` and `offset` parameters (default limit: 50, max: 500)
7. Neo4j queries optimized with indexes on document_id and metadata fields
8. Integration tests verify list filtering, document retrieval, and deletion workflows

---

## Tasks / Subtasks

- [ ] **Task 1: Create list documents endpoint** (AC: 1, 6)
  - [ ] Add `GET /api/v1/documents` to documents router
  - [ ] Implement pagination with limit and offset parameters
  - [ ] Set default limit to 50, max limit to 500
  - [ ] Query Neo4j for Document nodes
  - [ ] Return document_id, filename, metadata, ingestion_date, status, size
  - [ ] Add pagination metadata to response (total_count, has_more)

- [ ] **Task 2: Implement metadata filtering** (AC: 2)
  - [ ] Parse query parameters for metadata field filters
  - [ ] Build dynamic Cypher WHERE clause for metadata filters
  - [ ] Support multiple metadata field filters (AND logic)
  - [ ] Support date range filtering (ingestion_date_from, ingestion_date_to)
  - [ ] Support status filtering (status=indexed, status=failed, etc.)
  - [ ] Use parameterized Cypher queries

- [ ] **Task 3: Create get document details endpoint** (AC: 3)
  - [ ] Add `GET /api/v1/documents/{document_id}` to documents router
  - [ ] Query Neo4j for Document node by ID
  - [ ] Query related ParsedContent node via HAS_CONTENT relationship
  - [ ] Return full document details with metadata
  - [ ] Include parsed content preview (first 500 characters)
  - [ ] Return 404 if document not found

- [ ] **Task 4: Create delete document endpoint** (AC: 4, 5)
  - [ ] Add `DELETE /api/v1/documents/{document_id}` to documents router
  - [ ] Delete Document node from Neo4j
  - [ ] Delete related ParsedContent node
  - [ ] Delete associated graph entities and relationships (if any from Epic 3)
  - [ ] Make operation idempotent (return 204 even if not found)
  - [ ] Log deletion operation

- [ ] **Task 5: Implement Neo4j document service** (AC: 1, 3, 4, 7)
  - [ ] Create `shared/database/document_repository.py`
  - [ ] Implement `async def list_documents(filters, limit, offset)` method
  - [ ] Implement `async def get_document_by_id(doc_id)` method
  - [ ] Implement `async def delete_document(doc_id)` method
  - [ ] Implement `async def count_documents(filters)` method for pagination
  - [ ] Use parameterized Cypher queries
  - [ ] Leverage Neo4j indexes for performance

- [ ] **Task 6: Create response models** (AC: 1, 3)
  - [ ] Create `DocumentListItem` Pydantic model
  - [ ] Create `DocumentListResponse` model with pagination metadata
  - [ ] Create `DocumentDetail` Pydantic model
  - [ ] Create `ParsedContentPreview` Pydantic model
  - [ ] Add OpenAPI documentation examples

- [ ] **Task 7: Optimize Neo4j indexes** (AC: 7)
  - [ ] Create index on Document.id (if not exists from Story 2.3)
  - [ ] Create index on Document.status
  - [ ] Create index on Document.ingestion_date
  - [ ] Create composite index on metadata fields (if supported)
  - [ ] Document index creation in migration script

- [ ] **Task 8: Create integration tests** (AC: 8)
  - [ ] Create `services/api/tests/integration/test_document_management.py`
  - [ ] Test list documents with pagination
  - [ ] Test list documents with metadata filtering
  - [ ] Test list documents with date range filtering
  - [ ] Test list documents with status filtering
  - [ ] Test get document details (success)
  - [ ] Test get document details (404 not found)
  - [ ] Test delete document (success)
  - [ ] Test delete document idempotency (multiple deletes)

---

## Dev Notes

### Tech Stack
[Source: architecture/tech-stack.md]

- **Python**: 3.11+ (async/await support)
- **Backend Framework**: FastAPI 0.115+ (REST API, query parameters)
- **Validation**: Pydantic 2.x (request/response models)
- **Graph Database**: Neo4j 5.x (document storage and querying)
- **Neo4j Driver**: neo4j Python driver (Cypher queries)
- **Testing Framework**: pytest with pytest-asyncio
- **HTTP Testing**: httpx AsyncClient

### Project Structure
[Source: architecture/unified-project-structure.md]

File locations for implementation:

```
services/api/
├── routers/
│   └── documents.py             # Add list, get, delete endpoints
├── models/
│   ├── requests.py              # DocumentFilters
│   └── responses.py             # DocumentListResponse, DocumentDetail
└── tests/
    └── integration/
        └── test_document_management.py

shared/
├── database/
│   ├── __init__.py
│   └── document_repository.py   # Neo4j document queries
└── models/
    └── document.py              # Document domain models

scripts/
└── create_indexes.py            # Neo4j index creation script
```

### Component Architecture
[Source: architecture/components.md]

**Document Management Responsibility:**
Provide CRUD operations for documents in the knowledge base, including listing, filtering, retrieval, and deletion.

**Key Interfaces to Implement:**
- `GET /api/v1/documents` - List documents with filtering and pagination
- `GET /api/v1/documents/{document_id}` - Get document details
- `DELETE /api/v1/documents/{document_id}` - Delete document
- `async def list_documents(filters, limit, offset)` - Repository method
- `async def delete_document_cascade(doc_id)` - Delete with cascade

**Dependencies:**
- Neo4j Database (document storage)
- Document Ingestion Service (Story 2.3)

### API Endpoint Specification
[Source: Epic 2 Story 2.6 AC]

**Endpoint:** `GET /api/v1/documents`

**Query Parameters:**
- `limit` (integer, default: 50, max: 500) - Number of documents per page
- `offset` (integer, default: 0) - Pagination offset
- `status` (string, optional) - Filter by status (parsing, queued, indexed, failed)
- `ingestion_date_from` (ISO 8601 date, optional) - Filter by date range start
- `ingestion_date_to` (ISO 8601 date, optional) - Filter by date range end
- `{metadata_field}` (any, optional) - Filter by metadata field (e.g., `department=engineering`)

**Request Example:**
```bash
# List all documents (default pagination)
GET /api/v1/documents

# List documents with filters
GET /api/v1/documents?department=engineering&status=indexed&limit=20&offset=0

# List documents by date range
GET /api/v1/documents?ingestion_date_from=2025-10-01&ingestion_date_to=2025-10-16
```

**Response Format (200 OK):**
```json
{
  "documents": [
    {
      "document_id": "550e8400-e29b-41d4-a716-446655440000",
      "filename": "technical-spec.pdf",
      "metadata": {
        "author": "John Doe",
        "department": "engineering",
        "tags": ["technical", "api"]
      },
      "ingestion_date": "2025-10-16T14:30:00Z",
      "status": "indexed",
      "size_bytes": 1048576
    },
    {
      "document_id": "660f9511-f3ac-52e5-b827-557766551111",
      "filename": "design-doc.docx",
      "metadata": {
        "author": "Jane Smith",
        "department": "engineering",
        "tags": ["design", "architecture"]
      },
      "ingestion_date": "2025-10-16T13:20:00Z",
      "status": "indexed",
      "size_bytes": 524288
    }
  ],
  "pagination": {
    "total_count": 150,
    "limit": 50,
    "offset": 0,
    "has_more": true
  }
}
```

**Endpoint:** `GET /api/v1/documents/{document_id}`

**Request Example:**
```bash
GET /api/v1/documents/550e8400-e29b-41d4-a716-446655440000
```

**Response Format (200 OK):**
```json
{
  "document_id": "550e8400-e29b-41d4-a716-446655440000",
  "filename": "technical-spec.pdf",
  "metadata": {
    "author": "John Doe",
    "department": "engineering",
    "tags": ["technical", "api"],
    "date_created": "2025-10-15"
  },
  "ingestion_date": "2025-10-16T14:30:00Z",
  "status": "indexed",
  "size_bytes": 1048576,
  "parsed_content": {
    "format": "pdf",
    "page_count": 25,
    "text_blocks": 120,
    "images": 5,
    "tables": 3,
    "preview": "This technical specification document describes the API architecture for the RAG Engine system. The system consists of multiple microservices including FastAPI REST API, LightRAG service, and RAG-Anything document parsing service..."
  },
  "entity_count": 45,
  "relationship_count": 78
}
```

**Error Response (404 Not Found):**
```json
{
  "error": {
    "code": "DOCUMENT_NOT_FOUND",
    "message": "Document with ID 550e8400-e29b-41d4-a716-446655440000 not found"
  }
}
```

**Endpoint:** `DELETE /api/v1/documents/{document_id}`

**Request Example:**
```bash
DELETE /api/v1/documents/550e8400-e29b-41d4-a716-446655440000
```

**Response Format (204 No Content):**
No response body. Status 204 indicates successful deletion.

**Note on Idempotency:**
Deleting a non-existent document also returns 204 (no error).

### Neo4j Query Implementation
[Source: Epic 2 Story 2.6 AC1, AC4, AC7, architecture/core-workflows.md]

**List Documents Query:**
```cypher
MATCH (d:Document)
WHERE ($status IS NULL OR d.status = $status)
  AND ($ingestion_date_from IS NULL OR d.ingestion_date >= datetime($ingestion_date_from))
  AND ($ingestion_date_to IS NULL OR d.ingestion_date <= datetime($ingestion_date_to))
  AND ($metadata_filter IS NULL OR d.metadata CONTAINS $metadata_filter)
RETURN d.id AS document_id,
       d.filename AS filename,
       d.metadata AS metadata,
       d.ingestion_date AS ingestion_date,
       d.status AS status,
       d.size_bytes AS size_bytes
ORDER BY d.ingestion_date DESC
SKIP $offset
LIMIT $limit
```

**Count Documents Query (for pagination):**
```cypher
MATCH (d:Document)
WHERE ($status IS NULL OR d.status = $status)
  AND ($ingestion_date_from IS NULL OR d.ingestion_date >= datetime($ingestion_date_from))
  AND ($ingestion_date_to IS NULL OR d.ingestion_date <= datetime($ingestion_date_to))
  AND ($metadata_filter IS NULL OR d.metadata CONTAINS $metadata_filter)
RETURN count(d) AS total_count
```

**Get Document Details Query:**
```cypher
MATCH (d:Document {id: $document_id})
OPTIONAL MATCH (d)-[:HAS_CONTENT]->(pc:ParsedContent)
RETURN d.id AS document_id,
       d.filename AS filename,
       d.metadata AS metadata,
       d.ingestion_date AS ingestion_date,
       d.status AS status,
       d.size_bytes AS size_bytes,
       pc.format AS format,
       pc.text AS text,
       pc.tables AS tables,
       pc.images AS images,
       pc.page_count AS page_count
```

**Delete Document Query (Cascade):**
```cypher
MATCH (d:Document {id: $document_id})
OPTIONAL MATCH (d)-[:HAS_CONTENT]->(pc:ParsedContent)
DETACH DELETE d, pc
```

### Document Repository Implementation
[Source: architecture/coding-standards.md]

```python
# shared/database/document_repository.py
from typing import List, Dict, Optional
from datetime import datetime
from uuid import UUID
from neo4j import AsyncGraphDatabase

class DocumentRepository:
    """Repository for document CRUD operations."""

    def __init__(self, neo4j_driver):
        self.driver = neo4j_driver

    async def list_documents(
        self,
        filters: Dict[str, any],
        limit: int = 50,
        offset: int = 0
    ) -> List[Dict]:
        """List documents with filtering and pagination."""
        async with self.driver.session() as session:
            result = await session.run(
                """
                MATCH (d:Document)
                WHERE ($status IS NULL OR d.status = $status)
                  AND ($ingestion_date_from IS NULL OR d.ingestion_date >= datetime($ingestion_date_from))
                  AND ($ingestion_date_to IS NULL OR d.ingestion_date <= datetime($ingestion_date_to))
                RETURN d.id AS document_id,
                       d.filename AS filename,
                       d.metadata AS metadata,
                       d.ingestion_date AS ingestion_date,
                       d.status AS status,
                       d.size_bytes AS size_bytes
                ORDER BY d.ingestion_date DESC
                SKIP $offset
                LIMIT $limit
                """,
                status=filters.get("status"),
                ingestion_date_from=filters.get("ingestion_date_from"),
                ingestion_date_to=filters.get("ingestion_date_to"),
                offset=offset,
                limit=limit
            )
            return [record.data() async for record in result]

    async def count_documents(self, filters: Dict[str, any]) -> int:
        """Count documents matching filters."""
        async with self.driver.session() as session:
            result = await session.run(
                """
                MATCH (d:Document)
                WHERE ($status IS NULL OR d.status = $status)
                  AND ($ingestion_date_from IS NULL OR d.ingestion_date >= datetime($ingestion_date_from))
                  AND ($ingestion_date_to IS NULL OR d.ingestion_date <= datetime($ingestion_date_to))
                RETURN count(d) AS total_count
                """,
                status=filters.get("status"),
                ingestion_date_from=filters.get("ingestion_date_from"),
                ingestion_date_to=filters.get("ingestion_date_to")
            )
            record = await result.single()
            return record["total_count"] if record else 0

    async def get_document_by_id(self, document_id: UUID) -> Optional[Dict]:
        """Get document details by ID."""
        async with self.driver.session() as session:
            result = await session.run(
                """
                MATCH (d:Document {id: $document_id})
                OPTIONAL MATCH (d)-[:HAS_CONTENT]->(pc:ParsedContent)
                RETURN d, pc
                """,
                document_id=str(document_id)
            )
            record = await result.single()
            if not record:
                return None

            doc = record["d"]
            parsed_content = record["pc"]

            return {
                "document_id": doc["id"],
                "filename": doc["filename"],
                "metadata": doc["metadata"],
                "ingestion_date": doc["ingestion_date"],
                "status": doc["status"],
                "size_bytes": doc["size_bytes"],
                "parsed_content": parsed_content if parsed_content else None
            }

    async def delete_document(self, document_id: UUID):
        """Delete document and associated content (idempotent)."""
        async with self.driver.session() as session:
            await session.run(
                """
                MATCH (d:Document {id: $document_id})
                OPTIONAL MATCH (d)-[:HAS_CONTENT]->(pc:ParsedContent)
                DETACH DELETE d, pc
                """,
                document_id=str(document_id)
            )
```

### Neo4j Index Creation
[Source: Epic 2 Story 2.6 AC7]

```python
# scripts/create_indexes.py
from neo4j import GraphDatabase

def create_document_indexes(driver):
    """Create indexes for document queries."""
    with driver.session() as session:
        # Index on document ID (primary key)
        session.run("""
            CREATE INDEX document_id_index IF NOT EXISTS
            FOR (d:Document) ON (d.id)
        """)

        # Index on document status
        session.run("""
            CREATE INDEX document_status_index IF NOT EXISTS
            FOR (d:Document) ON (d.status)
        """)

        # Index on ingestion date
        session.run("""
            CREATE INDEX document_ingestion_date_index IF NOT EXISTS
            FOR (d:Document) ON (d.ingestion_date)
        """)

        print("Document indexes created successfully")
```

### Coding Standards
[Source: architecture/coding-standards.md]

**Critical Rules:**
- **Type Safety:** Use Pydantic V2 for all request/response models
- **Neo4j Queries:** Always use parameterized queries; never string interpolation
- **Async/Await:** All database operations must use async
- **Error Handling:** Return 404 for not found; 204 for successful deletion
- **Logging:** Log all document operations (list, get, delete) with request_id
- **Idempotency:** DELETE endpoint must be idempotent (no error if already deleted)

**Naming Conventions:**
- Modules: `snake_case` (e.g., `document_repository.py`)
- Classes: `PascalCase` (e.g., `DocumentRepository`)
- Functions: `snake_case` (e.g., `async def list_documents()`)
- Constants: `SCREAMING_SNAKE_CASE` (e.g., `DEFAULT_PAGE_LIMIT`)

### Testing Standards
[Source: architecture/testing-strategy.md]

**Testing Requirements:**
- **Integration Tests (services/api/tests/integration/):**
  - Test list documents with pagination
  - Test list documents with metadata filtering
  - Test list documents with date range filtering
  - Test list documents with status filtering
  - Test get document details (success and 404)
  - Test delete document (success and idempotency)
  - Use httpx AsyncClient for API requests
  - Use pytest-asyncio for async tests

**Test File Organization:**
```
services/api/tests/
├── integration/
│   └── test_document_management.py
└── conftest.py                  # Fixtures for test documents
```

**Test Example:**
```python
import pytest
from httpx import AsyncClient
from fastapi import status

@pytest.mark.asyncio
async def test_list_documents_pagination(
    async_client: AsyncClient,
    test_documents: List[str]  # Fixture with 100 test documents
):
    """Test document listing with pagination."""
    # First page
    response = await async_client.get(
        "/api/v1/documents?limit=20&offset=0",
        headers={"X-API-Key": "test-key-123"}
    )

    assert response.status_code == status.HTTP_200_OK
    result = response.json()
    assert len(result["documents"]) == 20
    assert result["pagination"]["limit"] == 20
    assert result["pagination"]["offset"] == 0
    assert result["pagination"]["total_count"] == 100
    assert result["pagination"]["has_more"] is True

    # Second page
    response = await async_client.get(
        "/api/v1/documents?limit=20&offset=20",
        headers={"X-API-Key": "test-key-123"}
    )

    assert response.status_code == status.HTTP_200_OK
    result = response.json()
    assert len(result["documents"]) == 20
    assert result["pagination"]["offset"] == 20

@pytest.mark.asyncio
async def test_list_documents_metadata_filter(
    async_client: AsyncClient,
    test_documents_with_metadata: List[str]
):
    """Test document listing with metadata filtering."""
    response = await async_client.get(
        "/api/v1/documents?department=engineering&tags=api",
        headers={"X-API-Key": "test-key-123"}
    )

    assert response.status_code == status.HTTP_200_OK
    result = response.json()

    # Verify all documents match filters
    for doc in result["documents"]:
        assert doc["metadata"]["department"] == "engineering"
        assert "api" in doc["metadata"]["tags"]

@pytest.mark.asyncio
async def test_get_document_details(
    async_client: AsyncClient,
    test_document_id: str
):
    """Test getting document details."""
    response = await async_client.get(
        f"/api/v1/documents/{test_document_id}",
        headers={"X-API-Key": "test-key-123"}
    )

    assert response.status_code == status.HTTP_200_OK
    result = response.json()
    assert result["document_id"] == test_document_id
    assert "filename" in result
    assert "metadata" in result
    assert "parsed_content" in result
    assert "preview" in result["parsed_content"]

@pytest.mark.asyncio
async def test_get_document_not_found(async_client: AsyncClient):
    """Test getting non-existent document returns 404."""
    fake_id = "00000000-0000-0000-0000-000000000000"

    response = await async_client.get(
        f"/api/v1/documents/{fake_id}",
        headers={"X-API-Key": "test-key-123"}
    )

    assert response.status_code == status.HTTP_404_NOT_FOUND
    error = response.json()
    assert error["error"]["code"] == "DOCUMENT_NOT_FOUND"

@pytest.mark.asyncio
async def test_delete_document_success(
    async_client: AsyncClient,
    test_document_id: str
):
    """Test successful document deletion."""
    # Delete document
    response = await async_client.delete(
        f"/api/v1/documents/{test_document_id}",
        headers={"X-API-Key": "test-key-123"}
    )

    assert response.status_code == status.HTTP_204_NO_CONTENT

    # Verify document is deleted
    response = await async_client.get(
        f"/api/v1/documents/{test_document_id}",
        headers={"X-API-Key": "test-key-123"}
    )

    assert response.status_code == status.HTTP_404_NOT_FOUND

@pytest.mark.asyncio
async def test_delete_document_idempotent(
    async_client: AsyncClient,
    test_document_id: str
):
    """Test delete operation is idempotent."""
    # Delete document first time
    response = await async_client.delete(
        f"/api/v1/documents/{test_document_id}",
        headers={"X-API-Key": "test-key-123"}
    )
    assert response.status_code == status.HTTP_204_NO_CONTENT

    # Delete same document again (idempotent)
    response = await async_client.delete(
        f"/api/v1/documents/{test_document_id}",
        headers={"X-API-Key": "test-key-123"}
    )
    assert response.status_code == status.HTTP_204_NO_CONTENT
```

### Previous Story Insights
[Source: docs/stories/2.3.ingestion-api.md]

**Relevant Learnings from Story 2.3:**
- Neo4j Document node schema already defined
- Document storage uses parameterized Cypher queries
- Indexes on document_id and metadata fields
- Return 404 for not found resources
- Use structured logging for all operations

**Technical Patterns to Follow:**
- Use repository pattern for database operations
- Implement pagination with limit/offset parameters
- Support flexible filtering with query parameters
- Return appropriate HTTP status codes (200, 204, 404)
- Make delete operations idempotent

---

## Testing

### Test File Locations
[Source: architecture/testing-strategy.md]

**Integration Tests:**
- `services/api/tests/integration/test_document_management.py` - API endpoint tests

**Test Fixtures:**
- Test documents created via ingestion API
- Metadata samples for filtering tests

### Testing Approach
[Source: architecture/testing-strategy.md]

1. **Integration Tests (90%)**: Test API endpoints with real Neo4j database
2. **Unit Tests (10%)**: Test repository methods with mocked database
3. **Coverage Target**: 80%+ for document_repository.py and routers/documents.py

### Required Test Scenarios
- List documents with default pagination
- List documents with custom limit/offset
- List documents filtered by metadata
- List documents filtered by date range
- List documents filtered by status
- Get document details (success)
- Get document details (404 not found)
- Delete document (success)
- Delete document (idempotent - multiple deletes)
- Neo4j index creation and optimization

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-16 | 1.0 | Story created from Epic 2 | Sarah (PO Agent) |

---

## Dev Agent Record

### Agent Model Used
*[To be populated by Dev Agent during implementation]*

### Debug Log References
*[To be populated by Dev Agent during implementation]*

### Completion Notes
*[To be populated by Dev Agent during implementation]*

### File List
*[To be populated by Dev Agent during implementation]*

---

## QA Results
*[To be populated by QA Agent after implementation]*

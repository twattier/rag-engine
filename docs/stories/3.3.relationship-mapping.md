# Story 3.3: Implement Relationship Mapping and Graph Construction

**Epic:** Epic 3 - Graph-Based Retrieval, Knowledge Graph Construction & Visualization
**Story ID:** 3.3
**Status:** Draft
**Estimated Effort:** 8 story points (2-3 days)

---

## User Story

**As a** knowledge seeker,
**I want** LightRAG to discover relationships between entities across documents,
**so that** I can explore connected knowledge through graph traversal.

---

## Acceptance Criteria

1. LightRAG extracts relationships between entities with: relationship_type, source_entity, target_entity, confidence_score
2. Relationship types include: MENTIONS, RELATED_TO, PART_OF, IMPLEMENTS, DEPENDS_ON, LOCATED_IN, AUTHORED_BY (extensible)
3. Neo4j graph schema extended: Relationship edges between Entity nodes with properties (type, confidence, source_document_id)
4. Cross-document relationships: entities mentioned in multiple documents connected through graph
5. Graph construction preserves document hierarchy: Document → Section → Entity relationships
6. Performance optimization: batch entity/relationship creation in Neo4j (transactions of 100 entities)
7. Graph statistics endpoint `GET /api/v1/graph/stats` returns: total_entities, total_relationships, entity_type_distribution
8. Integration test verifies relationships exist between entities from same document and cross-document relationships

---

## Tasks / Subtasks

- [ ] **Task 1: Implement relationship extraction** (AC: 1, 2)
  - [ ] Create `services/lightrag-integration/app/services/relationship_extractor.py`
  - [ ] Implement `extract_relationships(entities: List[Entity], document_text: str) -> List[Relationship]`
  - [ ] Build LLM prompt with entity list and relationship type examples
  - [ ] Parse LLM response to extract: source_entity_name, target_entity_name, relationship_type, confidence_score
  - [ ] Define Pydantic model `Relationship(source, target, type, confidence, source_doc_id)`
  - [ ] Support extensible relationship types via configuration (future: add to entity-types.yaml or separate config)

- [ ] **Task 2: Create Neo4j relationship schema** (AC: 3)
  - [ ] Define relationship properties: `type` (string), `confidence` (float), `source_doc_id` (UUID), `created_at` (datetime)
  - [ ] Implement Cypher query to create relationships between Entity nodes:
    ```cypher
    MATCH (e1:Entity {name: $source_name}), (e2:Entity {name: $target_name})
    CREATE (e1)-[r:RELATIONSHIP {type: $rel_type, confidence: $confidence, source_doc_id: $doc_id}]->(e2)
    ```
  - [ ] Support multiple relationship types: MENTIONS, RELATED_TO, PART_OF, IMPLEMENTS, DEPENDS_ON, LOCATED_IN, AUTHORED_BY
  - [ ] Add generic `:RELATIONSHIP` label for all relationship types (allows polymorphic queries)

- [ ] **Task 3: Implement cross-document relationship linking** (AC: 4)
  - [ ] When entity extracted, query Neo4j for existing entities with same name across all documents
  - [ ] Create `RELATED_TO` relationships between same entities across documents
  - [ ] Track cross-document links: `(:Entity)-[:APPEARS_IN]->(:Document)` for multi-doc entities
  - [ ] Add entity provenance tracking: list of all documents mentioning entity
  - [ ] Update deduplication logic (Story 3.2) to create cross-document links

- [ ] **Task 4: Preserve document hierarchy in graph** (AC: 5)
  - [ ] Extend ParsedContent nodes with section information if available
  - [ ] Create optional hierarchy: `(:Document)-[:HAS_SECTION]->(:Section)-[:CONTAINS]->(:Entity)`
  - [ ] If no sections: fallback to `(:Document)-[:CONTAINS]->(:Entity)` (already implemented in 3.2)
  - [ ] Parse document structure from RAG-Anything (headings, sections) if available
  - [ ] Store section metadata: section_title, page_number, section_index

- [ ] **Task 5: Implement batch creation for performance** (AC: 6)
  - [ ] Create `services/lightrag-integration/app/utils/neo4j_batch.py`
  - [ ] Implement `BatchWriter` class with configurable batch size (default 100)
  - [ ] Buffer entity and relationship creation operations
  - [ ] Execute batched Cypher transactions: `UNWIND $batch AS item CREATE ...`
  - [ ] Add error handling: if batch fails, retry with smaller batches (binary search for problematic items)
  - [ ] Log batch performance: entities_per_second, relationships_per_second

- [ ] **Task 6: Create graph statistics endpoint** (AC: 7)
  - [ ] Create `services/api/app/routers/graph.py` (or extend existing)
  - [ ] Implement `GET /api/v1/graph/stats` endpoint
  - [ ] Query Neo4j for statistics:
    - Total entities: `MATCH (e:Entity) RETURN count(e)`
    - Total relationships: `MATCH ()-[r:RELATIONSHIP]->() RETURN count(r)`
    - Entity type distribution: `MATCH (e:Entity) RETURN e.type, count(e) ORDER BY count(e) DESC`
    - Relationship type distribution: `MATCH ()-[r:RELATIONSHIP]->() RETURN r.type, count(r)`
  - [ ] Return `GraphStatsResponse` Pydantic model with all metrics
  - [ ] Add OpenAPI documentation

- [ ] **Task 7: Create integration tests** (AC: 8)
  - [ ] Create `services/api/tests/integration/test_relationship_mapping.py`
  - [ ] Test: Upload CV document, extract entities and relationships
  - [ ] Test: Verify `(:Entity)-[:RELATIONSHIP]->(:Entity)` relationships created
  - [ ] Test: Upload second document mentioning same entity (e.g., "Python")
  - [ ] Test: Verify cross-document relationship: entity linked to both documents
  - [ ] Test: Call `/api/v1/graph/stats` endpoint, validate response structure
  - [ ] Test: Performance test - upload 10 documents, measure relationship creation time

---

## Dev Notes

### Tech Stack
[Source: [architecture/tech-stack.md](../architecture/tech-stack.md)]

- **LightRAG**: 0.x (relationship extraction, graph construction)
- **Neo4j**: 5.x (graph storage, batch transactions)
- **FastAPI**: 0.115+ (graph statistics API)

### Relationship Extraction Flow

```
Entities Extracted (from Story 3.2)
  → Build relationship extraction prompt with entity pairs
  → Call LLM to identify relationships between entities
  → Parse LLM response → List[Relationship]
  → Batch relationships into groups of 100
  → Execute batched Cypher transactions
  → Check for cross-document entity matches
  → Create cross-document RELATED_TO relationships
  → Log relationship creation metrics
```

### Neo4j Schema Extensions

**Relationship Schema:**
```cypher
(:Entity)-[:RELATIONSHIP {
  type: String,  // MENTIONS, RELATED_TO, PART_OF, etc.
  confidence: Float,  // 0.0-1.0
  source_doc_id: UUID,
  created_at: DateTime
}]->(:Entity)
```

**Cross-Document Links:**
```cypher
(:Entity)-[:APPEARS_IN]->(:Document)
// Allows querying: "Which documents mention Python?"
```

**Document Hierarchy (Optional):**
```cypher
(:Document)-[:HAS_SECTION]->(:Section {
  title: String,
  page_number: Int,
  section_index: Int
})-[:CONTAINS]->(:Entity)
```

### Relationship Types

**Predefined Relationship Types:**
- `MENTIONS`: Entity A mentions entity B in text
- `RELATED_TO`: Generic semantic relationship
- `PART_OF`: Entity A is part of entity B (e.g., "Database Admin" PART_OF "Engineering")
- `IMPLEMENTS`: Technology implements concept (e.g., "PostgreSQL" IMPLEMENTS "Database")
- `DEPENDS_ON`: Dependency relationship (e.g., "API Service" DEPENDS_ON "Neo4j")
- `LOCATED_IN`: Geographic relationship (e.g., "Google" LOCATED_IN "San Francisco")
- `AUTHORED_BY`: Document authorship (e.g., "CV" AUTHORED_BY "John Doe")

**Extensibility:** Add new relationship types via configuration (future enhancement).

### Batch Creation Performance

**Batch Writer Implementation:**
```python
class BatchWriter:
    def __init__(self, session, batch_size=100):
        self.session = session
        self.batch_size = batch_size
        self.entity_buffer = []
        self.relationship_buffer = []

    async def add_entity(self, entity: Dict):
        self.entity_buffer.append(entity)
        if len(self.entity_buffer) >= self.batch_size:
            await self.flush_entities()

    async def flush_entities(self):
        if not self.entity_buffer:
            return

        self.session.run("""
            UNWIND $batch AS item
            CREATE (e:Entity {
                id: item.id,
                name: item.name,
                type: item.type,
                embedding: item.embedding,
                confidence_score: item.confidence
            })
        """, batch=self.entity_buffer)

        self.entity_buffer.clear()
```

### Graph Statistics API

**Response Schema:**
```python
class GraphStatsResponse(BaseModel):
    total_entities: int
    total_relationships: int
    entity_type_distribution: Dict[str, int]  # {"person": 45, "company": 23, ...}
    relationship_type_distribution: Dict[str, int]  # {"MENTIONS": 120, "RELATED_TO": 67, ...}
    total_documents: int
    cross_document_entities: int  # Entities appearing in >1 document
```

### Coding Standards
[Source: [architecture/coding-standards.md](../architecture/coding-standards.md)]

**Critical Rules:**
- **Type Safety**: Type hints in all functions
- **Neo4j Transactions**: Use transactions for batch operations
- **Error Handling**: Retry failed batches with smaller sizes
- **Logging**: Log batch performance metrics
- **Async/Await**: All DB operations async

---

## Testing

### Test File Locations
[Source: [architecture/testing-strategy.md](../architecture/testing-strategy.md)]

**Integration Tests:**
- `services/api/tests/integration/test_relationship_mapping.py`

**Unit Tests:**
- `services/lightrag-integration/tests/test_relationship_extractor.py`
- `services/lightrag-integration/tests/test_batch_writer.py`

### Testing Approach

1. **Integration Test**: Upload CVs → extract relationships → validate in Neo4j
2. **Unit Test**: Mock LLM, test relationship parsing logic
3. **Cross-Document Test**: Upload duplicate mentions, verify linking
4. **Performance Test**: Batch creation speed (target: >100 entities/sec)
5. **Coverage Target**: 80%+ for relationship extraction and batch writer

### Test Scenarios

- **Relationship Extraction**: "John Doe" AUTHORED_BY "CV", "Python" PART_OF "Skills"
- **Cross-Document Linking**: "Python" in CV1 and CV2 → single entity, linked to both docs
- **Batch Performance**: Create 1000 entities in <10 seconds
- **Graph Statistics**: Call `/api/v1/graph/stats`, verify counts match Neo4j

**Test Example:**
```python
@pytest.mark.asyncio
async def test_cross_document_relationship_linking(async_client, neo4j_session):
    """Test entities mentioned in multiple documents are linked."""
    # Upload first CV mentioning "Python"
    doc1_id = await upload_cv(async_client, "cv_000.pdf")
    await wait_for_status(async_client, doc1_id, "indexed")

    # Upload second CV also mentioning "Python"
    doc2_id = await upload_cv(async_client, "cv_001.pdf")
    await wait_for_status(async_client, doc2_id, "indexed")

    # Query for "Python" entity
    result = neo4j_session.run("""
        MATCH (e:Entity {name: 'Python', type: 'technology'})-[:APPEARS_IN]->(d:Document)
        RETURN d.id AS doc_id
    """)

    linked_docs = [rec["doc_id"] for rec in result]

    # Verify Python linked to both documents
    assert doc1_id in linked_docs
    assert doc2_id in linked_docs
    assert len(linked_docs) == 2
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-17 | 1.0 | Story created from Epic 3 | Sarah (PO Agent) |

---

## Dev Agent Record

### Agent Model Used
<!-- Populated during implementation -->

### Debug Log References
<!-- Populated during implementation -->

### Completion Notes
<!-- Populated during implementation -->

### File List
<!-- Populated during implementation -->

---

## QA Results
<!-- Results from QA Agent review -->

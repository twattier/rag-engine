# Story 1.3: Create API Service with FastAPI and Health Check Endpoint

**Epic:** Epic 1 - Foundation & Core Infrastructure
**Story ID:** 1.3
**Status:** Ready for Development
**Estimated Effort:** 4 story points (5-7 hours)

---

## User Story

**As a** developer,
**I want** a FastAPI-based API service with a health check endpoint,
**so that** I can verify the API service is running and responsive.

---

## Acceptance Criteria

### AC1: FastAPI Application Structure
- [ ] `services/api/` contains working FastAPI application:
  - `app/main.py` with FastAPI app initialization
  - `app/routers/` directory for endpoint organization
  - `app/dependencies.py` for shared dependencies (database connections, etc.)
  - `app/config.py` for configuration management using Pydantic Settings

### AC2: Health Check Endpoint
- [ ] Health check endpoint `GET /health` returns:
  - Status code: 200
  - JSON response: `{"status": "healthy", "service": "rag-engine-api", "version": "0.1.0"}`

### AC3: Root Endpoint
- [ ] Root endpoint `GET /` returns:
  - Status code: 200
  - JSON response with API information and link to docs: `{"message": "RAG Engine API", "docs_url": "/docs", "version": "0.1.0"}`

### AC4: OpenAPI Documentation
- [ ] OpenAPI documentation auto-generated by FastAPI accessible at:
  - Swagger UI: `http://localhost:8000/docs`
  - ReDoc: `http://localhost:8000/redoc`
  - OpenAPI JSON schema: `http://localhost:8000/openapi.json`

### AC5: Docker Container
- [ ] API service runs in Docker container defined in `services/api/Dockerfile`:
  - Based on `python:3.11-slim`
  - Installs dependencies from `requirements.txt`
  - Exposes port 8000
  - Runs with `uvicorn` ASGI server

### AC6: Docker Compose Integration
- [ ] `docker-compose.yml` includes API service configuration:
  - Builds from `services/api/Dockerfile`
  - Exposes port 8000 to host
  - Mounts source code as volume for development hot-reload
  - Sets environment variables from `.env`

### AC7: API Health Test Script
- [ ] `scripts/test-api-health.sh` successfully calls `/health` endpoint and validates response

---

## Implementation Tasks

### Task 1: Create FastAPI Application Structure

**File:** `services/api/app/main.py`

```python
"""
RAG Engine FastAPI application.
Provides REST API endpoints for document ingestion, retrieval, and knowledge graph exploration.
"""

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager

from app.config import settings
from app.routers import health

# Version
__version__ = "0.1.0"


@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Lifecycle manager for application startup and shutdown.
    """
    # Startup
    print(f"Starting RAG Engine API v{__version__}")
    print(f"Log level: {settings.LOG_LEVEL}")
    print(f"Neo4j URI: {settings.NEO4J_URI}")

    yield

    # Shutdown
    print("Shutting down RAG Engine API")


# Initialize FastAPI app
app = FastAPI(
    title="RAG Engine API",
    description=(
        "Production-ready RAG API with graph-based retrieval, multi-format document processing, "
        "and multiple integration interfaces (Open-WebUI, MCP, n8n, REST)."
    ),
    version=__version__,
    docs_url="/docs",
    redoc_url="/redoc",
    openapi_url="/openapi.json",
    lifespan=lifespan,
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
app.include_router(health.router, tags=["health"])


@app.get("/", tags=["root"])
async def root():
    """
    Root endpoint providing API information.
    """
    return {
        "message": "RAG Engine API",
        "version": __version__,
        "docs_url": "/docs",
        "health_url": "/health",
    }
```

**File:** `services/api/app/__init__.py`

```python
"""RAG Engine API service."""
__version__ = "0.1.0"
```

**File:** `services/api/app/config.py`

```python
"""
Configuration management for RAG Engine API.
Uses Pydantic Settings for type-safe environment variable loading.
"""

from pydantic_settings import BaseSettings, SettingsConfigDict
from typing import List


class Settings(BaseSettings):
    """Application settings loaded from environment variables."""

    # Application
    APP_NAME: str = "RAG Engine API"
    VERSION: str = "0.1.0"

    # API Configuration
    API_PORT: int = 8000
    API_WORKERS: int = 1
    API_KEY: str = "change-me-in-production"
    RATE_LIMIT_PER_MINUTE: int = 100

    # Neo4j Configuration
    NEO4J_URI: str = "bolt://neo4j:7687"
    NEO4J_AUTH: str = "neo4j/password"
    NEO4J_DATABASE: str = "neo4j"

    # CORS Configuration
    CORS_ORIGINS: List[str] = ["http://localhost:3000", "http://localhost:8080"]

    # Logging
    LOG_LEVEL: str = "INFO"
    LOG_FORMAT: str = "json"

    # Request Configuration
    REQUEST_TIMEOUT: int = 120
    MAX_CONCURRENT_REQUESTS: int = 10

    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=True,
    )


# Global settings instance
settings = Settings()
```

**File:** `services/api/app/dependencies.py`

```python
"""
Shared dependencies for FastAPI routes.
Includes database connections, authentication, etc.
"""

from typing import Annotated
from fastapi import Header, HTTPException, status

from app.config import settings


async def verify_api_key(
    authorization: Annotated[str | None, Header()] = None
) -> str:
    """
    Verify API key from Authorization header.

    Args:
        authorization: Authorization header value (format: "Bearer <api_key>")

    Returns:
        API key if valid

    Raises:
        HTTPException: If API key is missing or invalid
    """
    if authorization is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Missing Authorization header",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # Parse "Bearer <token>" format
    parts = authorization.split()
    if len(parts) != 2 or parts[0].lower() != "bearer":
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid Authorization header format. Expected: 'Bearer <api_key>'",
            headers={"WWW-Authenticate": "Bearer"},
        )

    api_key = parts[1]

    # Validate API key
    if api_key != settings.API_KEY:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid API key",
            headers={"WWW-Authenticate": "Bearer"},
        )

    return api_key


# Type alias for dependency injection
APIKeyDep = Annotated[str, Header(dependency=verify_api_key)]
```

**File:** `services/api/app/routers/__init__.py`

```python
"""API routers."""
```

**File:** `services/api/app/routers/health.py`

```python
"""
Health check endpoints for monitoring and status verification.
"""

from fastapi import APIRouter
from pydantic import BaseModel
from datetime import datetime

router = APIRouter()


class HealthResponse(BaseModel):
    """Health check response model."""
    status: str
    service: str
    version: str
    timestamp: datetime


@router.get("/health", response_model=HealthResponse)
async def health_check():
    """
    Health check endpoint.

    Returns basic service status. Story 1.4 will enhance this with
    dependency checks (Neo4j, LightRAG, etc.).

    Returns:
        HealthResponse: Service health status
    """
    return HealthResponse(
        status="healthy",
        service="rag-engine-api",
        version="0.1.0",
        timestamp=datetime.utcnow(),
    )
```

### Task 2: Update `requirements.txt`

Verify `services/api/requirements.txt` includes (created in Story 1.1):

```
fastapi==0.115.0
uvicorn[standard]==0.30.0
pydantic==2.8.0
pydantic-settings==2.4.0
python-dotenv==1.0.1
structlog==24.4.0
neo4j==5.23.0
httpx==0.27.0
python-multipart==0.0.9
```

### Task 3: Update Dockerfile

Verify `services/api/Dockerfile` (created in Story 1.1):

```dockerfile
FROM python:3.11-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    build-essential \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements and install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Expose port
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

# Run application (development mode with hot-reload)
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]
```

### Task 4: Verify Docker Compose Configuration

Verify `docker-compose.yml` includes API service (created in Story 1.1):

```yaml
api:
  build:
    context: ./services/api
    dockerfile: Dockerfile
  container_name: rag-engine-api
  ports:
    - "${API_PORT:-8000}:8000"
  environment:
    - NEO4J_URI=bolt://neo4j:7687
    - NEO4J_AUTH=${NEO4J_AUTH:-neo4j/password}
    - NEO4J_DATABASE=${NEO4J_DATABASE:-neo4j}
    - API_KEY=${API_KEY:-change-me-in-production}
    - LOG_LEVEL=${LOG_LEVEL:-INFO}
    - LOG_FORMAT=${LOG_FORMAT:-json}
    - CORS_ORIGINS=${CORS_ORIGINS:-http://localhost:3000,http://localhost:8080}
  volumes:
    - ./services/api:/app
    - ./shared:/app/shared
  depends_on:
    neo4j:
      condition: service_healthy
  networks:
    - rag-engine-network
  command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
  healthcheck:
    test: ["CMD-SHELL", "curl -f http://localhost:8000/health || exit 1"]
    interval: 10s
    timeout: 5s
    retries: 5
```

### Task 5: Create API Health Test Script

**File:** `scripts/test-api-health.sh`

```bash
#!/bin/bash
# API health check test script for RAG Engine

set -e

API_URL="${API_URL:-http://localhost:8000}"
TIMEOUT=30
INTERVAL=2

echo "Testing RAG Engine API at ${API_URL}..."

# Function to test endpoint
test_endpoint() {
    local endpoint=$1
    local expected_status=$2
    local description=$3

    echo -n "Testing ${description}... "

    response=$(curl -s -w "\n%{http_code}" "${API_URL}${endpoint}")
    http_code=$(echo "$response" | tail -n1)
    body=$(echo "$response" | head -n-1)

    if [ "$http_code" -eq "$expected_status" ]; then
        echo "✓ PASS (HTTP $http_code)"
        echo "  Response: $body"
        return 0
    else
        echo "✗ FAIL (HTTP $http_code, expected $expected_status)"
        echo "  Response: $body"
        return 1
    fi
}

# Wait for API to be ready
echo "Waiting for API to be ready (timeout: ${TIMEOUT}s)..."
elapsed=0
while [ $elapsed -lt $TIMEOUT ]; do
    if curl -s -f "${API_URL}/health" > /dev/null 2>&1; then
        echo "✓ API is ready"
        break
    fi
    sleep $INTERVAL
    elapsed=$((elapsed + INTERVAL))
    echo "  Waiting... (${elapsed}s / ${TIMEOUT}s)"
done

if [ $elapsed -ge $TIMEOUT ]; then
    echo "✗ Timeout waiting for API to be ready"
    exit 1
fi

# Run tests
echo ""
echo "Running API tests..."
echo "===================="

test_endpoint "/" 200 "Root endpoint"
echo ""

test_endpoint "/health" 200 "Health check endpoint"
echo ""

test_endpoint "/docs" 200 "Swagger UI documentation"
echo ""

test_endpoint "/openapi.json" 200 "OpenAPI schema"
echo ""

# Test health check response structure
echo -n "Validating health check response structure... "
health_response=$(curl -s "${API_URL}/health")

# Check required fields exist
if echo "$health_response" | grep -q '"status"' && \
   echo "$health_response" | grep -q '"service"' && \
   echo "$health_response" | grep -q '"version"'; then
    echo "✓ PASS"
    echo "  Response contains required fields: status, service, version"
else
    echo "✗ FAIL"
    echo "  Missing required fields in response"
    echo "  Response: $health_response"
    exit 1
fi

echo ""
echo "===================="
echo "✅ All API health tests passed!"
echo ""
echo "API is ready at: ${API_URL}"
echo "  - Swagger UI: ${API_URL}/docs"
echo "  - ReDoc: ${API_URL}/redoc"
echo "  - Health Check: ${API_URL}/health"
```

**Make script executable:**
```bash
chmod +x scripts/test-api-health.sh
```

### Task 6: Create Service README

**File:** `services/api/README.md`

```markdown
# RAG Engine API Service

FastAPI-based REST API service for RAG Engine, providing unified interface for document ingestion, retrieval, and knowledge graph operations.

## Overview

The API service acts as the **orchestration layer** for RAG Engine, routing requests to:
- **LightRAG service**: Graph-based retrieval and entity extraction
- **RAG-Anything service**: Multi-format document parsing
- **Neo4j database**: Direct graph queries and statistics

## Running Locally

### Via Docker Compose (Recommended)
```bash
# From repository root
docker-compose up -d api

# View logs
docker-compose logs -f api

# Access API
open http://localhost:8000/docs
```

### Standalone Development
```bash
# Install dependencies
cd services/api
pip install -r requirements.txt

# Set environment variables
export NEO4J_URI=bolt://localhost:7687
export NEO4J_AUTH=neo4j/password
export API_KEY=test-key

# Run with hot-reload
uvicorn app.main:app --reload --port 8000
```

## API Endpoints

### Story 1.3 (Current)
- `GET /` - Root endpoint with API information
- `GET /health` - Basic health check
- `GET /docs` - Swagger UI documentation
- `GET /redoc` - ReDoc documentation
- `GET /openapi.json` - OpenAPI schema

### Future Stories
- `POST /api/v1/documents/ingest` - Ingest document (Epic 2)
- `POST /api/v1/query` - Query knowledge base (Epic 3)
- `GET /api/v1/graph/stats` - Graph statistics (Epic 3)
- And more...

## Configuration

Configuration via environment variables (see `.env.example`):

| Variable | Description | Default |
|----------|-------------|---------|
| `API_PORT` | API service port | 8000 |
| `API_KEY` | API authentication key | change-me-in-production |
| `NEO4J_URI` | Neo4j connection URI | bolt://neo4j:7687 |
| `NEO4J_AUTH` | Neo4j credentials | neo4j/password |
| `LOG_LEVEL` | Logging level | INFO |
| `CORS_ORIGINS` | Allowed CORS origins | http://localhost:3000,http://localhost:8080 |

## Testing

```bash
# Run health check test
./scripts/test-api-health.sh

# Run unit tests (when available)
pytest tests/unit/api/

# Run integration tests (when available)
pytest tests/integration/api/
```

## Architecture

```
app/
├── main.py              # FastAPI application initialization
├── config.py            # Configuration management (Pydantic Settings)
├── dependencies.py      # Shared dependencies (auth, DB connections)
├── routers/             # API route handlers
│   ├── health.py        # Health check endpoints
│   └── ...              # Future routers (documents, query, etc.)
├── models/              # Pydantic request/response models (future)
└── services/            # Business logic layer (future)
```

## Development Notes

- **Hot-reload enabled**: Code changes automatically reload the server
- **Shared code**: `shared/` directory mounted for access to common models/utils
- **Dependencies**: Service depends on Neo4j being healthy before starting
- **Authentication**: Story 1.3 includes basic health check (no auth). Story 4.2 adds API key authentication.

## Next Steps

- Story 1.4: Add Neo4j connectivity check to `/health` endpoint
- Story 1.5: Implement structured logging with structlog
- Epic 2: Add document ingestion endpoints
- Epic 3: Add query and retrieval endpoints
```

---

## Testing Requirements

### Unit Tests
- [ ] Test health check endpoint returns correct structure
- [ ] Test root endpoint returns API information
- [ ] Test configuration loading from environment variables
- [ ] Test CORS middleware configuration

### Integration Tests
- [ ] Build Docker image successfully
- [ ] Start API container and verify health check responds
- [ ] Access Swagger UI at `/docs`
- [ ] Access OpenAPI schema at `/openapi.json`

### Manual Testing
- [ ] Start API service: `docker-compose up -d api`
- [ ] Run health test script: `./scripts/test-api-health.sh`
- [ ] Access Swagger UI in browser: `http://localhost:8000/docs`
- [ ] Test root endpoint: `curl http://localhost:8000/`
- [ ] Test health endpoint: `curl http://localhost:8000/health`

---

## Dependencies

- **Depends On:**
  - Story 1.1 (repository structure, Dockerfile, requirements.txt)
  - Story 1.2 (Neo4j running for docker-compose dependency)
- **Blocks:** Story 1.4 (health monitoring needs API service)

---

## Definition of Done

- [ ] All acceptance criteria met
- [ ] FastAPI application running and accessible
- [ ] Health check endpoint functional
- [ ] OpenAPI documentation generated
- [ ] Test script passes
- [ ] Service README complete
- [ ] Manual testing completed
- [ ] Code committed to repository
- [ ] Story reviewed by PO (Sarah)

---

## Notes

- This story establishes the **API foundation** but minimal endpoints
- Authentication (API keys) added in Epic 4 Story 4.2
- Enhanced health checks (Neo4j connectivity) added in Story 1.4
- Structured logging added in Story 1.5
- CORS configured for future Open-WebUI integration
- Hot-reload enabled for development productivity

---

**Change Log:**

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-15 | 1.0 | Story created from PRD | Sarah (PO Agent) |

# Story 1.4: Implement Service Health Monitoring and Neo4j Connection Verification

**Epic:** Epic 1 - Foundation & Core Infrastructure
**Story ID:** 1.4
**Status:** Ready for Development
**Estimated Effort:** 3 story points (4-5 hours)

---

## User Story

**As a** platform operator,
**I want** the API service to verify Neo4j connectivity and report all service health statuses,
**so that** I can quickly diagnose infrastructure issues.

---

## Acceptance Criteria

### AC1: Enhanced Health Check Response
- [ ] Enhanced health check endpoint `GET /health` returns:
  ```json
  {
    "status": "healthy",
    "service": "rag-engine-api",
    "version": "0.1.0",
    "dependencies": {
      "neo4j": {
        "status": "healthy",
        "response_time_ms": 45
      }
    },
    "timestamp": "2025-10-15T10:30:00Z"
  }
  ```

### AC2: Active Neo4j Connectivity Test
- [ ] Health check performs active Neo4j connectivity test:
  - Attempts connection to Neo4j
  - Executes simple query (e.g., `RETURN 1`)
  - Measures response time
  - Returns "unhealthy" status if connection fails or timeout exceeds 5 seconds

### AC3: Unhealthy Status Handling
- [ ] If Neo4j is unreachable, health check returns:
  - Status code: 503 (Service Unavailable)
  - JSON response with `"status": "unhealthy"` and error details

### AC4: Neo4j Connection Manager
- [ ] `shared/utils/neo4j_client.py` implements reusable Neo4j connection manager:
  - Connection pooling
  - Connection retry logic (3 attempts with exponential backoff)
  - Graceful error handling with structured logging

### AC5: Health Check Error Logging
- [ ] API service logs health check failures with structured JSON logs including:
  - Timestamp
  - Log level (ERROR)
  - Service name
  - Error message and stack trace

### AC6: Health Monitoring Documentation
- [ ] Documentation updated in `docs/health-monitoring.md` explaining:
  - Health endpoint usage
  - Interpreting health check responses
  - Common failure modes and troubleshooting steps

---

## Implementation Tasks

### Task 1: Create Neo4j Connection Manager

**File:** `shared/utils/__init__.py`
```python
"""Shared utilities for RAG Engine."""
```

**File:** `shared/utils/neo4j_client.py`

```python
"""
Neo4j connection manager with connection pooling and retry logic.
"""

import time
from typing import Optional, Any
from contextlib import contextmanager
from neo4j import GraphDatabase, Driver, Session
from neo4j.exceptions import ServiceUnavailable, AuthError
import structlog

logger = structlog.get_logger(__name__)


class Neo4jClient:
    """
    Neo4j connection manager with connection pooling and error handling.
    """

    def __init__(
        self,
        uri: str,
        auth: tuple[str, str],
        database: str = "neo4j",
        max_connection_pool_size: int = 50,
        connection_timeout: float = 5.0,
    ):
        """
        Initialize Neo4j client.

        Args:
            uri: Neo4j connection URI (e.g., "bolt://localhost:7687")
            auth: Tuple of (username, password)
            database: Database name
            max_connection_pool_size: Maximum connection pool size
            connection_timeout: Connection timeout in seconds
        """
        self.uri = uri
        self.auth = auth
        self.database = database
        self.max_connection_pool_size = max_connection_pool_size
        self.connection_timeout = connection_timeout
        self._driver: Optional[Driver] = None

        logger.info(
            "neo4j_client_initialized",
            uri=uri,
            database=database,
        )

    def connect(self) -> Driver:
        """
        Create Neo4j driver with connection pooling.

        Returns:
            Neo4j driver instance

        Raises:
            ServiceUnavailable: If Neo4j is not reachable
            AuthError: If authentication fails
        """
        if self._driver is None:
            try:
                self._driver = GraphDatabase.driver(
                    self.uri,
                    auth=self.auth,
                    max_connection_pool_size=self.max_connection_pool_size,
                    connection_timeout=self.connection_timeout,
                )
                logger.info("neo4j_driver_connected", uri=self.uri)
            except (ServiceUnavailable, AuthError) as e:
                logger.error(
                    "neo4j_connection_failed",
                    uri=self.uri,
                    error=str(e),
                    error_type=type(e).__name__,
                )
                raise

        return self._driver

    def close(self):
        """Close Neo4j driver and connection pool."""
        if self._driver is not None:
            self._driver.close()
            self._driver = None
            logger.info("neo4j_driver_closed", uri=self.uri)

    @contextmanager
    def session(self) -> Session:
        """
        Context manager for Neo4j session.

        Yields:
            Neo4j session

        Example:
            ```python
            with client.session() as session:
                result = session.run("RETURN 1 AS num")
                print(result.single()["num"])
            ```
        """
        driver = self.connect()
        session = driver.session(database=self.database)
        try:
            yield session
        finally:
            session.close()

    def verify_connectivity(self, retries: int = 3) -> tuple[bool, Optional[float], Optional[str]]:
        """
        Verify Neo4j connectivity with retry logic.

        Args:
            retries: Number of connection attempts

        Returns:
            Tuple of (success, response_time_ms, error_message)
        """
        for attempt in range(retries):
            try:
                start_time = time.time()

                with self.session() as session:
                    result = session.run("RETURN 1 AS test")
                    record = result.single()
                    assert record["test"] == 1

                response_time_ms = (time.time() - start_time) * 1000

                logger.info(
                    "neo4j_connectivity_verified",
                    response_time_ms=response_time_ms,
                    attempt=attempt + 1,
                )

                return True, response_time_ms, None

            except (ServiceUnavailable, AuthError, Exception) as e:
                error_msg = f"{type(e).__name__}: {str(e)}"

                if attempt < retries - 1:
                    # Exponential backoff: 1s, 2s, 4s
                    wait_time = 2 ** attempt
                    logger.warning(
                        "neo4j_connectivity_check_failed_retrying",
                        attempt=attempt + 1,
                        retries=retries,
                        wait_time=wait_time,
                        error=error_msg,
                    )
                    time.sleep(wait_time)
                else:
                    logger.error(
                        "neo4j_connectivity_check_failed",
                        attempts=retries,
                        error=error_msg,
                    )
                    return False, None, error_msg

        return False, None, "Max retries exceeded"

    def execute_query(self, query: str, parameters: dict[str, Any] = None) -> list[dict]:
        """
        Execute Cypher query and return results.

        Args:
            query: Cypher query string
            parameters: Query parameters

        Returns:
            List of result records as dictionaries

        Raises:
            ServiceUnavailable: If Neo4j is not reachable
        """
        with self.session() as session:
            result = session.run(query, parameters or {})
            return [dict(record) for record in result]


def parse_neo4j_auth(auth_string: str) -> tuple[str, str]:
    """
    Parse NEO4J_AUTH environment variable format.

    Args:
        auth_string: Auth string in format "username/password"

    Returns:
        Tuple of (username, password)

    Raises:
        ValueError: If auth string format is invalid
    """
    parts = auth_string.split("/")
    if len(parts) != 2:
        raise ValueError(
            f"Invalid NEO4J_AUTH format: {auth_string}. Expected 'username/password'"
        )
    return tuple(parts)
```

### Task 2: Update Health Check Router

**File:** `services/api/app/routers/health.py`

```python
"""
Health check endpoints for monitoring and status verification.
"""

from fastapi import APIRouter, status
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from datetime import datetime
from typing import Optional

from app.config import settings
from shared.utils.neo4j_client import Neo4jClient, parse_neo4j_auth
import structlog

logger = structlog.get_logger(__name__)

router = APIRouter()


class DependencyHealth(BaseModel):
    """Health status of a dependency."""
    status: str
    response_time_ms: Optional[float] = None
    error: Optional[str] = None


class HealthResponse(BaseModel):
    """Health check response model."""
    status: str
    service: str
    version: str
    dependencies: dict[str, DependencyHealth]
    timestamp: datetime


# Initialize Neo4j client (singleton)
_neo4j_client: Optional[Neo4jClient] = None


def get_neo4j_client() -> Neo4jClient:
    """Get or create Neo4j client instance."""
    global _neo4j_client
    if _neo4j_client is None:
        username, password = parse_neo4j_auth(settings.NEO4J_AUTH)
        _neo4j_client = Neo4jClient(
            uri=settings.NEO4J_URI,
            auth=(username, password),
            database=settings.NEO4J_DATABASE,
        )
    return _neo4j_client


@router.get("/health", response_model=HealthResponse)
async def health_check():
    """
    Health check endpoint with dependency verification.

    Checks:
    - Neo4j database connectivity and response time

    Returns HTTP 200 if all dependencies are healthy.
    Returns HTTP 503 if any critical dependency is unhealthy.

    Returns:
        HealthResponse: Service health status with dependency checks
    """
    dependencies = {}
    overall_status = "healthy"

    # Check Neo4j connectivity
    try:
        neo4j_client = get_neo4j_client()
        success, response_time_ms, error_msg = neo4j_client.verify_connectivity(retries=3)

        if success:
            dependencies["neo4j"] = DependencyHealth(
                status="healthy",
                response_time_ms=response_time_ms,
            )
        else:
            dependencies["neo4j"] = DependencyHealth(
                status="unhealthy",
                error=error_msg,
            )
            overall_status = "unhealthy"
            logger.error(
                "health_check_neo4j_unhealthy",
                error=error_msg,
            )

    except Exception as e:
        error_msg = f"{type(e).__name__}: {str(e)}"
        dependencies["neo4j"] = DependencyHealth(
            status="unhealthy",
            error=error_msg,
        )
        overall_status = "unhealthy"
        logger.error(
            "health_check_neo4j_exception",
            error=error_msg,
            exc_info=True,
        )

    # Create response
    response_data = HealthResponse(
        status=overall_status,
        service="rag-engine-api",
        version=settings.VERSION,
        dependencies=dependencies,
        timestamp=datetime.utcnow(),
    )

    # Return 503 if unhealthy, 200 if healthy
    if overall_status == "unhealthy":
        return JSONResponse(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            content=response_data.model_dump(mode="json"),
        )

    return response_data
```

### Task 3: Update API Dependencies

Update `services/api/requirements.txt` to ensure `structlog` is included (should already be present from Story 1.1):

```
fastapi==0.115.0
uvicorn[standard]==0.30.0
pydantic==2.8.0
pydantic-settings==2.4.0
python-dotenv==1.0.1
structlog==24.4.0
neo4j==5.23.0
httpx==0.27.0
python-multipart==0.0.9
```

### Task 4: Initialize Structlog in Main Application

**File:** `services/api/app/main.py` (update lifespan)

```python
"""
RAG Engine FastAPI application.
"""

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
import structlog

from app.config import settings
from app.routers import health

__version__ = "0.1.0"


def configure_logging():
    """Configure structured logging with structlog."""
    if settings.LOG_FORMAT == "json":
        # Production: JSON logs
        structlog.configure(
            processors=[
                structlog.stdlib.filter_by_level,
                structlog.stdlib.add_logger_name,
                structlog.stdlib.add_log_level,
                structlog.stdlib.PositionalArgumentsFormatter(),
                structlog.processors.TimeStamper(fmt="iso"),
                structlog.processors.StackInfoRenderer(),
                structlog.processors.format_exc_info,
                structlog.processors.UnicodeDecoder(),
                structlog.processors.JSONRenderer(),
            ],
            wrapper_class=structlog.stdlib.BoundLogger,
            logger_factory=structlog.stdlib.LoggerFactory(),
            cache_logger_on_first_use=True,
        )
    else:
        # Development: Console logs
        structlog.configure(
            processors=[
                structlog.stdlib.filter_by_level,
                structlog.stdlib.add_logger_name,
                structlog.stdlib.add_log_level,
                structlog.stdlib.PositionalArgumentsFormatter(),
                structlog.processors.TimeStamper(fmt="iso"),
                structlog.processors.StackInfoRenderer(),
                structlog.processors.format_exc_info,
                structlog.processors.UnicodeDecoder(),
                structlog.dev.ConsoleRenderer(),
            ],
            wrapper_class=structlog.stdlib.BoundLogger,
            logger_factory=structlog.stdlib.LoggerFactory(),
            cache_logger_on_first_use=True,
        )


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Lifecycle manager for application startup and shutdown."""
    # Startup
    configure_logging()
    logger = structlog.get_logger(__name__)

    logger.info(
        "api_service_starting",
        version=__version__,
        log_level=settings.LOG_LEVEL,
        neo4j_uri=settings.NEO4J_URI,
    )

    yield

    # Shutdown
    logger.info("api_service_shutting_down")


# Initialize FastAPI app
app = FastAPI(
    title="RAG Engine API",
    description=(
        "Production-ready RAG API with graph-based retrieval, multi-format document processing, "
        "and multiple integration interfaces (Open-WebUI, MCP, n8n, REST)."
    ),
    version=__version__,
    docs_url="/docs",
    redoc_url="/redoc",
    openapi_url="/openapi.json",
    lifespan=lifespan,
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
app.include_router(health.router, tags=["health"])


@app.get("/", tags=["root"])
async def root():
    """Root endpoint providing API information."""
    return {
        "message": "RAG Engine API",
        "version": __version__,
        "docs_url": "/docs",
        "health_url": "/health",
    }
```

### Task 5: Create Health Monitoring Documentation

**File:** `docs/health-monitoring.md`

```markdown
# Health Monitoring Guide

This guide explains how to use RAG Engine's health check endpoints for monitoring and troubleshooting.

## Health Check Endpoint

**Endpoint:** `GET /health`

**Purpose:** Verify that RAG Engine API and all dependencies are operational.

### Healthy Response (HTTP 200)

```json
{
  "status": "healthy",
  "service": "rag-engine-api",
  "version": "0.1.0",
  "dependencies": {
    "neo4j": {
      "status": "healthy",
      "response_time_ms": 45.2
    }
  },
  "timestamp": "2025-10-15T10:30:00.000Z"
}
```

**Fields:**
- `status`: Overall health status (`healthy` or `unhealthy`)
- `service`: Service name
- `version`: API version
- `dependencies`: Health status of each dependency
- `timestamp`: UTC timestamp of health check

### Unhealthy Response (HTTP 503)

```json
{
  "status": "unhealthy",
  "service": "rag-engine-api",
  "version": "0.1.0",
  "dependencies": {
    "neo4j": {
      "status": "unhealthy",
      "error": "ServiceUnavailable: Unable to connect to Neo4j at bolt://neo4j:7687"
    }
  },
  "timestamp": "2025-10-15T10:35:00.000Z"
}
```

**HTTP Status Codes:**
- `200 OK`: All systems operational
- `503 Service Unavailable`: One or more dependencies unhealthy

## Using Health Checks

### Manual Testing

```bash
# Basic health check
curl http://localhost:8000/health

# Pretty-printed JSON
curl -s http://localhost:8000/health | jq

# Check HTTP status code
curl -I http://localhost:8000/health
```

### Docker Healthchecks

RAG Engine API service includes built-in Docker healthcheck:

```yaml
# docker-compose.yml
api:
  healthcheck:
    test: ["CMD-SHELL", "curl -f http://localhost:8000/health || exit 1"]
    interval: 10s
    timeout: 5s
    retries: 5
```

Check container health:
```bash
docker ps
# Look for "(healthy)" status

docker inspect rag-engine-api --format='{{.State.Health.Status}}'
```

### Monitoring Integration

#### Prometheus

Health check can be scraped by Prometheus for alerting:

```yaml
# prometheus.yml
scrape_configs:
  - job_name: 'rag-engine-health'
    metrics_path: '/health'
    static_configs:
      - targets: ['api:8000']
```

#### Uptime Monitoring

Services like UptimeRobot, Pingdom, or Healthchecks.io can monitor the health endpoint:

- **URL:** `http://your-domain.com/health`
- **Expected status:** 200
- **Interval:** 60 seconds (recommended)

## Troubleshooting

### Neo4j Unhealthy

**Symptoms:**
```json
{
  "dependencies": {
    "neo4j": {
      "status": "unhealthy",
      "error": "ServiceUnavailable: Unable to connect"
    }
  }
}
```

**Causes & Solutions:**

1. **Neo4j container not running**
   ```bash
   docker ps | grep neo4j
   # If not running:
   docker-compose up -d neo4j
   ```

2. **Neo4j still starting up**
   - Wait 10-30 seconds for Neo4j to initialize
   - Check logs: `docker logs rag-engine-neo4j`

3. **Authentication failure**
   - Verify `NEO4J_AUTH` in `.env` matches Neo4j configuration
   - Reset password if needed (see Neo4j Setup Guide)

4. **Network connectivity**
   - Verify services are on same Docker network
   - Check: `docker network inspect rag-engine-network`

5. **Neo4j out of memory**
   - Check logs for `OutOfMemoryError`
   - Increase heap size in `.env`: `NEO4J_HEAP_MAX=4g`
   - Restart: `docker-compose restart neo4j`

### Slow Response Times

**Symptoms:**
```json
{
  "dependencies": {
    "neo4j": {
      "status": "healthy",
      "response_time_ms": 2500  // > 1 second
    }
  }
}
```

**Causes & Solutions:**

1. **Resource contention**
   - Check system resources: `docker stats`
   - Increase Docker memory allocation

2. **Large knowledge base**
   - Increase Neo4j page cache: `NEO4J_PAGECACHE=4g`
   - Add indexes (done automatically by LightRAG)

3. **Network latency**
   - Ensure API and Neo4j are on same Docker network
   - Avoid running over slow network links

### Health Check Timeout

**Symptoms:**
- Health endpoint times out (no response)
- Docker healthcheck fails repeatedly

**Causes & Solutions:**

1. **API service crashed**
   ```bash
   docker logs rag-engine-api
   # Look for Python exceptions or errors
   ```

2. **API service not started**
   ```bash
   docker-compose up -d api
   ```

3. **Port binding issue**
   - Check if port 8000 is in use
   - Change `API_PORT` in `.env` if needed

## Best Practices

### Production Deployments

1. **Monitor health endpoint regularly** (every 60s)
2. **Set up alerts** for unhealthy status
3. **Include health checks in load balancer** configuration
4. **Log health check failures** for post-mortem analysis

### Development

1. **Check health after code changes** to verify nothing broke
2. **Use health check in CI/CD** to validate deployment
3. **Test failure scenarios** (stop Neo4j, invalid credentials)

### Kubernetes/Orchestration

```yaml
# Example Kubernetes liveness and readiness probes
livenessProbe:
  httpGet:
    path: /health
    port: 8000
  initialDelaySeconds: 30
  periodSeconds: 10

readinessProbe:
  httpGet:
    path: /health
    port: 8000
  initialDelaySeconds: 10
  periodSeconds: 5
```

## Future Enhancements

Epic 5 will add additional monitoring capabilities:
- Detailed metrics endpoint (`/api/v1/metrics`)
- Prometheus-compatible metrics
- Performance counters and request statistics
- Resource usage monitoring

See Epic 5 Story 5.3 for details.
```

---

## Testing Requirements

### Unit Tests
- [ ] Test Neo4j client connection and retry logic
- [ ] Test health check with healthy Neo4j
- [ ] Test health check with unhealthy Neo4j
- [ ] Test auth string parsing

### Integration Tests
- [ ] Start API and Neo4j, verify health returns 200
- [ ] Stop Neo4j, verify health returns 503
- [ ] Simulate Neo4j connection timeout
- [ ] Verify retry logic with connection failures

### Manual Testing
- [ ] Start services: `docker-compose up -d`
- [ ] Check health when all healthy: `curl http://localhost:8000/health`
- [ ] Stop Neo4j: `docker-compose stop neo4j`
- [ ] Check health returns 503: `curl -I http://localhost:8000/health`
- [ ] Restart Neo4j: `docker-compose start neo4j`
- [ ] Verify health returns to 200

---

## Dependencies

- **Depends On:**
  - Story 1.2 (Neo4j deployed)
  - Story 1.3 (API service running)
- **Blocks:** Story 1.6 (deployment validation needs working health checks)

---

## Definition of Done

- [ ] All acceptance criteria met
- [ ] Neo4j client implemented with retry logic
- [ ] Health check enhanced with dependency verification
- [ ] Returns 503 when dependencies unhealthy
- [ ] Documentation complete
- [ ] All tests passing
- [ ] Manual testing completed
- [ ] Code committed to repository
- [ ] Story reviewed by PO (Sarah)

---

## Notes

- Retry logic uses exponential backoff (1s, 2s, 4s)
- Timeout set to 5 seconds for health check queries
- Structlog configured for both JSON (production) and console (development) logging
- Future stories will add checks for LightRAG and RAG-Anything services

---

**Change Log:**

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-15 | 1.0 | Story created from PRD | Sarah (PO Agent) |

# Story 2.2: Implement Metadata Schema Definition and Validation

**Epic:** Epic 2 - Multi-Format Document Ingestion Pipeline
**Story ID:** 2.2
**Status:** Draft
**Estimated Effort:** 3 story points (4-5 hours)

---

## User Story

**As a** knowledge base administrator,
**I want** to define custom metadata fields for my documents,
**so that** I can filter and organize documents by domain-specific attributes.

---

## Acceptance Criteria

1. `shared/models/metadata.py` defines Pydantic models for metadata schema configuration
2. Schema supports field types: string, integer, date, boolean, tags (list of strings)
3. Schema definition file `config/metadata-schema.yaml` allows users to define custom fields with: field name, type, required/optional, default value, description
4. Example schema includes common fields: author, department, date_created, tags, project_name, category
5. API validates document metadata against schema on ingestion, returning 422 for invalid metadata
6. `.env.example` includes `METADATA_SCHEMA_PATH` configuration variable
7. Documentation in `docs/metadata-configuration.md` explains schema definition with examples

---

## Tasks / Subtasks

- [ ] **Task 1: Create Pydantic metadata models** (AC: 1, 2)
  - [ ] Create `shared/models/metadata.py` module
  - [ ] Define `MetadataFieldType` enum (string, integer, date, boolean, tags)
  - [ ] Define `MetadataFieldDefinition` Pydantic model with field_name, type, required, default, description
  - [ ] Define `MetadataSchema` Pydantic model containing list of field definitions
  - [ ] Implement validation logic for field type constraints
  - [ ] Add type hints and docstrings

- [ ] **Task 2: Create YAML schema configuration file** (AC: 3, 4)
  - [ ] Create `config/` directory if not exists
  - [ ] Create `config/metadata-schema.yaml` with example schema
  - [ ] Define common fields: author, department, date_created, tags, project_name, category
  - [ ] Include field descriptions and constraints
  - [ ] Add comments explaining schema structure

- [ ] **Task 3: Implement schema loader and validator** (AC: 1, 5)
  - [ ] Create `shared/config/metadata_loader.py` module
  - [ ] Implement `load_metadata_schema(file_path)` function
  - [ ] Implement `validate_metadata(metadata_dict, schema)` function
  - [ ] Handle YAML parsing errors gracefully
  - [ ] Return validation errors with field-specific messages
  - [ ] Add caching for loaded schema to avoid repeated file reads

- [ ] **Task 4: Integrate validator into API service** (AC: 5)
  - [ ] Update `services/api/dependencies.py` to load metadata schema
  - [ ] Create FastAPI dependency for metadata validation
  - [ ] Add metadata validation to document ingestion endpoints
  - [ ] Return 422 Unprocessable Entity for validation failures
  - [ ] Include detailed error messages with field names

- [ ] **Task 5: Add environment configuration** (AC: 6)
  - [ ] Add `METADATA_SCHEMA_PATH` to `.env.example`
  - [ ] Set default value to `config/metadata-schema.yaml`
  - [ ] Update `services/api/config.py` to include schema path setting
  - [ ] Document environment variable in `.env.example` comments

- [ ] **Task 6: Create unit tests** (AC: 1, 2, 5)
  - [ ] Create `shared/tests/test_metadata.py`
  - [ ] Test MetadataFieldDefinition validation for each field type
  - [ ] Test MetadataSchema loading from YAML
  - [ ] Test metadata validation with valid data
  - [ ] Test metadata validation with invalid data (wrong types)
  - [ ] Test metadata validation with missing required fields
  - [ ] Test metadata validation with extra fields (should pass)

- [ ] **Task 7: Create documentation** (AC: 7)
  - [ ] Create `docs/metadata-configuration.md`
  - [ ] Document YAML schema structure with field definitions
  - [ ] Provide examples for each field type
  - [ ] Show domain-specific examples (legal, medical, technical)
  - [ ] Document validation error handling
  - [ ] Include troubleshooting section

---

## Dev Notes

### Tech Stack
[Source: architecture/tech-stack.md]

- **Python**: 3.11+ (type hints, Pydantic V2 support)
- **Validation**: Pydantic 2.x (data validation, schema generation)
- **YAML Parser**: PyYAML (configuration file parsing)
- **Backend Framework**: FastAPI 0.115+ (API integration, dependency injection)
- **Testing Framework**: pytest (unit tests)

### Project Structure
[Source: architecture/unified-project-structure.md]

File locations for implementation:

```
shared/
├── models/
│   ├── __init__.py
│   └── metadata.py              # Pydantic metadata models
├── config/
│   ├── __init__.py
│   └── metadata_loader.py       # Schema loader and validator
└── tests/
    ├── __init__.py
    └── test_metadata.py         # Unit tests

config/
└── metadata-schema.yaml         # YAML schema definition

services/api/
├── dependencies.py              # FastAPI dependencies (schema loader)
├── config.py                    # Settings with METADATA_SCHEMA_PATH
└── tests/
    └── test_metadata_validation.py  # Integration tests

docs/
└── metadata-configuration.md    # User documentation
```

### Component Architecture
[Source: architecture/components.md]

**Metadata Schema Responsibility:**
Define and validate custom metadata fields for document organization and filtering. Enables domain-specific attributes for knowledge base management.

**Key Interfaces to Implement:**
- `load_metadata_schema(file_path: str) -> MetadataSchema` - Load schema from YAML file
- `validate_metadata(metadata: dict, schema: MetadataSchema) -> ValidationResult` - Validate metadata against schema
- `get_metadata_schema() -> MetadataSchema` - FastAPI dependency for schema access

**Dependencies:**
- PyYAML for configuration parsing
- Pydantic V2 for model validation
- FastAPI for API integration

### Metadata Schema YAML Structure
[Source: Epic 2 Story 2.2 AC3]

Example schema structure:

```yaml
# config/metadata-schema.yaml
metadata_fields:
  - field_name: author
    type: string
    required: false
    default: "Unknown"
    description: "Document author name"

  - field_name: department
    type: string
    required: false
    description: "Department or organizational unit"

  - field_name: date_created
    type: date
    required: false
    description: "Document creation date (ISO 8601 format)"

  - field_name: tags
    type: tags
    required: false
    default: []
    description: "List of tags for categorization"

  - field_name: project_name
    type: string
    required: false
    description: "Associated project name"

  - field_name: category
    type: string
    required: false
    description: "Document category (e.g., report, manual, specification)"

  - field_name: version
    type: integer
    required: false
    default: 1
    description: "Document version number"

  - field_name: is_public
    type: boolean
    required: false
    default: false
    description: "Whether document is publicly accessible"
```

### Pydantic Model Structure
[Source: architecture/coding-standards.md]

Example Pydantic models:

```python
from __future__ import annotations
from enum import Enum
from typing import Any, List, Optional
from pydantic import BaseModel, Field, field_validator
from datetime import date

class MetadataFieldType(str, Enum):
    """Supported metadata field types."""
    STRING = "string"
    INTEGER = "integer"
    DATE = "date"
    BOOLEAN = "boolean"
    TAGS = "tags"

class MetadataFieldDefinition(BaseModel):
    """Definition of a single metadata field."""
    field_name: str = Field(..., description="Field name")
    type: MetadataFieldType = Field(..., description="Field data type")
    required: bool = Field(default=False, description="Whether field is required")
    default: Optional[Any] = Field(default=None, description="Default value")
    description: str = Field(..., description="Field description")

    @field_validator('default')
    @classmethod
    def validate_default_type(cls, v, info):
        """Ensure default value matches field type."""
        # Validation logic here
        return v

class MetadataSchema(BaseModel):
    """Complete metadata schema configuration."""
    metadata_fields: List[MetadataFieldDefinition] = Field(
        ...,
        description="List of metadata field definitions"
    )

    def validate_metadata(self, metadata: dict) -> dict:
        """Validate metadata dictionary against schema."""
        # Validation implementation
        pass
```

### API Validation Integration
[Source: architecture/core-workflows.md, architecture/components.md]

FastAPI dependency example:

```python
# services/api/dependencies.py
from functools import lru_cache
from shared.config.metadata_loader import load_metadata_schema
from shared.models.metadata import MetadataSchema
from services.api.config import get_settings

@lru_cache()
def get_metadata_schema() -> MetadataSchema:
    """Load and cache metadata schema."""
    settings = get_settings()
    return load_metadata_schema(settings.METADATA_SCHEMA_PATH)

# services/api/routers/documents.py
from fastapi import Depends, HTTPException, status

async def validate_document_metadata(
    metadata: dict,
    schema: MetadataSchema = Depends(get_metadata_schema)
):
    """Validate metadata against schema."""
    try:
        validated = schema.validate_metadata(metadata)
        return validated
    except ValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail={
                "error": {
                    "code": "INVALID_METADATA",
                    "message": "Metadata validation failed",
                    "fields": e.errors()
                }
            }
        )
```

### Coding Standards
[Source: architecture/coding-standards.md]

**Critical Rules:**
- **Type Safety:** Use Pydantic V2 for all models; strict type hints (`from __future__ import annotations`)
- **Error Handling:** Return standardized error responses with field-specific validation messages
- **Configuration:** Access schema path through Pydantic Settings; use `@lru_cache()` for schema loading
- **Validation:** Never expose internal validation errors; translate to user-friendly messages
- **YAML Parsing:** Handle YAML errors gracefully with clear error messages

**Naming Conventions:**
- Modules: `snake_case` (e.g., `metadata_loader.py`)
- Classes: `PascalCase` (e.g., `MetadataSchema`)
- Functions: `snake_case` (e.g., `load_metadata_schema()`)
- Constants: `SCREAMING_SNAKE_CASE` (e.g., `DEFAULT_SCHEMA_PATH`)
- Pydantic Models: Suffix with type (e.g., `MetadataFieldDefinition`)

### Testing Standards
[Source: architecture/testing-strategy.md]

**Testing Requirements:**
- **Unit Tests (shared/tests/test_metadata.py):**
  - Test each metadata field type validation (string, integer, date, boolean, tags)
  - Test required field validation
  - Test default value application
  - Test schema loading from YAML file
  - Test validation error messages
  - Use pytest fixtures for sample schemas

**Test File Organization:**
```
shared/tests/
├── conftest.py                  # Pytest fixtures (sample schemas)
├── test_metadata.py             # Metadata model tests
└── fixtures/
    ├── valid-schema.yaml
    ├── invalid-schema.yaml
    └── sample-metadata.json

services/api/tests/
├── integration/
│   └── test_metadata_validation.py  # API integration tests
└── fixtures/
    └── test-documents/
```

**Test Example:**
```python
import pytest
from shared.models.metadata import MetadataSchema, MetadataFieldType
from shared.config.metadata_loader import load_metadata_schema

def test_load_metadata_schema_success(tmp_path):
    """Test successful schema loading from YAML."""
    schema_file = tmp_path / "schema.yaml"
    schema_file.write_text("""
metadata_fields:
  - field_name: author
    type: string
    required: true
    description: "Document author"
""")

    schema = load_metadata_schema(str(schema_file))

    assert len(schema.metadata_fields) == 1
    assert schema.metadata_fields[0].field_name == "author"
    assert schema.metadata_fields[0].type == MetadataFieldType.STRING
    assert schema.metadata_fields[0].required is True

def test_validate_metadata_missing_required_field():
    """Test validation fails for missing required fields."""
    schema = MetadataSchema(metadata_fields=[
        MetadataFieldDefinition(
            field_name="author",
            type=MetadataFieldType.STRING,
            required=True,
            description="Author name"
        )
    ])

    metadata = {"title": "Test Document"}  # Missing 'author'

    with pytest.raises(ValidationError) as exc:
        schema.validate_metadata(metadata)

    assert "author" in str(exc.value)
    assert "required" in str(exc.value).lower()

def test_validate_metadata_wrong_type():
    """Test validation fails for wrong field types."""
    schema = MetadataSchema(metadata_fields=[
        MetadataFieldDefinition(
            field_name="version",
            type=MetadataFieldType.INTEGER,
            required=False,
            description="Version number"
        )
    ])

    metadata = {"version": "1.0"}  # String instead of integer

    with pytest.raises(ValidationError) as exc:
        schema.validate_metadata(metadata)

    assert "version" in str(exc.value)
    assert "integer" in str(exc.value).lower()

def test_validate_metadata_applies_defaults():
    """Test default values are applied for missing optional fields."""
    schema = MetadataSchema(metadata_fields=[
        MetadataFieldDefinition(
            field_name="tags",
            type=MetadataFieldType.TAGS,
            required=False,
            default=[],
            description="Document tags"
        )
    ])

    metadata = {}  # No tags provided
    validated = schema.validate_metadata(metadata)

    assert "tags" in validated
    assert validated["tags"] == []
```

### Previous Story Insights
[Source: docs/stories/2.1.integrate-rag-anything.md - Dev Notes]

**Relevant Learnings from Story 2.1:**
- Use Pydantic V2 for all data validation and serialization
- Configuration should be loaded at startup and cached
- Error messages must be clear and user-friendly
- Include comprehensive examples in documentation
- Test both valid and invalid input scenarios

**Technical Patterns to Follow:**
- Use FastAPI dependency injection for shared resources
- Implement validation as reusable functions
- Cache configuration files to avoid repeated I/O
- Return HTTP 422 for validation errors (Unprocessable Entity)

---

## Testing

### Test File Locations
[Source: architecture/testing-strategy.md]

**Unit Tests:**
- `shared/tests/test_metadata.py` - Metadata model and validation tests
- `shared/tests/conftest.py` - Pytest fixtures for schemas

**Integration Tests:**
- `services/api/tests/integration/test_metadata_validation.py` - API validation tests

**Test Fixtures:**
- `shared/tests/fixtures/valid-schema.yaml` - Valid schema examples
- `shared/tests/fixtures/invalid-schema.yaml` - Invalid schema for error testing
- `shared/tests/fixtures/sample-metadata.json` - Sample metadata for validation tests

### Testing Approach
[Source: architecture/testing-strategy.md]

1. **Unit Tests (70%)**: Test Pydantic models and validation logic in isolation
2. **Integration Tests (20%)**: Test FastAPI endpoint validation with real HTTP requests
3. **Coverage Target**: 80%+ for shared/models/metadata.py and shared/config/metadata_loader.py

### Required Test Scenarios
- Schema loading from valid YAML file
- Schema loading from invalid YAML (parse errors)
- Metadata validation with all field types (string, integer, date, boolean, tags)
- Required field validation (missing fields)
- Type validation (wrong types)
- Default value application
- Extra fields handling (should be allowed)
- API integration test with valid metadata
- API integration test with invalid metadata (422 response)

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-16 | 1.0 | Story created from Epic 2 | Sarah (PO Agent) |

---

## Dev Agent Record

### Agent Model Used
*[To be populated by Dev Agent during implementation]*

### Debug Log References
*[To be populated by Dev Agent during implementation]*

### Completion Notes
*[To be populated by Dev Agent during implementation]*

### File List
*[To be populated by Dev Agent during implementation]*

---

## QA Results
*[To be populated by QA Agent after implementation]*
